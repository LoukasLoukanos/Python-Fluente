# ***Python Fluente***

*Não é uma referência exaustiva de A a Z para Python. A ênfase da obra está nos recursos da linguagem exclusiva do Python ou que não se contram em muitas outras linguagens populares. Este também, em sua parte maior, é um livro sobre o número de linguagens e algumas de suas bibliotecas. Raramente é falado sobre os pacotes que não é um jogo de biblioteca, além do título de páginas do Python (PyPI) lista de mais de 60 mil bibliotecas e muitas outras extremidades.*

## **Sumário**
### ***➲ Prefácio — Pág. 17***
### ***➲ Parte I - Prólogo — Pág. 27***
  - **➥ Capítulo 1 - Modelo de dados do Python — Pág. 28**
    | Conteúdo | Pág./code |
    |:-:|:-:|
    | Um baralho pythônico | Pág. 29 <a href="#">→code</a> |
    | Como os métodos especiais são usados | Pág. 33 <a href="#">→code</a> |
    | Emulando tipos numéricos | Pág. 34 <a href="#">→code</a> |
    | Representação em string | Pág. 36 <a href="#">→code</a> |
    | Operadores aritméticos | Pág. 37 <a href="#">→code</a> |
    | Valor booleano de um tipo definido pelo usuário | Pág. 37 <a href="#">→code</a> |
    | Visão geral dos métodos especiais | Pág. 39 <a href="#">→code</a> |
    | Por que len não é um método? | Pág. 39 <a href="#">→code</a> |
    | Resumo do capítulo | Pág. 40 |
    | Leituras complementares | Pág. 41 |

</br>

### ***➲ Parte II - Estruturas de dados — Pág. 43***
  - **➥ Capítulo 2 - Uma coleção de sequências — Pág. 44**
    | Conteúdo | Pág./code |
    |:-:|:-:|
    | Visão geral das sequências embutidas | Pág. 45 <a href="#">→code</a> |
    | List comprehensions e expressões geradoras | Pág. 46 <a href="#">→code</a> |
    | List comprehensions e legibilidade | Pág. 46 <a href="#">→code</a> |
    | Comparação entre listcomps e map/filter | Pág. 48 <a href="#">→code</a> |
    | Produtos cartesianos | Pág. 49 <a href="#">→code</a> |
    | Expressões geradoras | Pág. 50 <a href="#">→code</a> |
    | Tuplas não são apenas listas imutáveis | Pág. 52 <a href="#">→code</a> |
    | Tuplas como registros | Pág. 52 <a href="#">→code</a> |
    | Desempacotamento de tuplas | Pág. 53 <a href="#">→code</a> |
    | Desempacotamento de tuplas aninhadas | Pág. 55 <a href="#">→code</a> |
    | Tuplas nomeadas | Pág. 56 <a href="#">→code</a> |
    | Tuplas como listas imutáveis | Pág. 58 <a href="#">→code</a> |
    | Fatiamento | Pág. 59 <a href="#">→code</a> |
    | Por que as fatias e os intervalos excluem o último item | Pág. 59 <a href="#">→code</a> |
    | Objetos slice | Pág. 60 <a href="#">→code</a> |
    | Fatiamento multidimensional e reticências | Pág. 62 <a href="#">→code</a> |
    | Atribuição de valores a fatias | Pág. 62 <a href="#">→code</a> |
    | Usando + e * com sequências | Pág. 63 <a href="#">→code</a> |
    | Criando listas de listas | Pág. 64 <a href="#">→code</a> |
    | Atribuições combinadas e sequências | Pág. 65 <a href="#">→code</a> |
    | O enigma da atribuição += | Pág. 67 <a href="#">→code</a> |
    | list.sort e a função embutida sorted | Pág. 69 <a href="#">→code</a> |
    | Administrando sequências ordenadas com bisect | Pág. 71 <a href="#">→code</a> |
    | Pesquisando com bisect | Pág. 71 <a href="#">→code</a> |
    | Inserção com bisect.insort | Pág. 74 <a href="#">→code</a> |
    | Quando uma lista não é a resposta | Pág. 75 <a href="#">→code</a> |
    | Arrays | Pág. 75 <a href="#">→code</a> |
    | Memory Views | Pág. 78 <a href="#">→code</a> |
    | NumPy e SciPy | Pág. 80 <a href="#">→code</a> |
    | Deques e outras filas | Pág. 82 <a href="#">→code</a> |
    | Resumo do capítulo | Pág. 86 |
    | Leituras complementares | Pág. 87 |

</br>

  - **➥ Capítulo 3 - Dicionários e conjuntos — Pág. 93**
    | Conteúdo | Pág./code |
    |:-:|:-:|
    | Tipos genéricos de mapeamento | Pág. 94 <a href="#">→code</a> |
    | dict comprehensions | Pág. 96 <a href="#">→code</a> |
    | Visão geral dos métodos comuns a mapeamentos | Pág. 97 <a href="#">→code</a> |
    | Tratando chaves ausentes com setdefault | Pág. 98 <a href="#">→code</a> |
    | Mapeamentos com consulta de chave flexível | Pág. 101 <a href="#">→code</a> |
    | defaultdict: outra abordagem para chaves ausentes | Pág. 101 <a href="#">→code</a> |
    | Método _ausente__ | Pág. 102 <a href="#">→code</a> |
    | Variações de dict | Pág. 105 <a href="#">→code</a> |
    | Criando subclasses de UserDict | Pág. 106 <a href="#">→code</a> |
    | Mapeamentos imutáveis | Pág. 108 <a href="#">→code</a> |
    | Teoria dos conjuntos | Pág. 109 <a href="#">→code</a> |
    | Literais de set | Pág. 111 <a href="#">→code</a> |
    | Set comprehensions | Pág. 113 <a href="#">→code</a> |
    | Operações de conjuntos | Pág. 113 <a href="#">→code</a> |
    | Por dentro de dict e set | Pág. 116 <a href="#">→code</a> |
    | Um experimento para testar o desempenho | Pág. 116 <a href="#">→code</a> |
    | Tabelas hash em dicionários | Pág. 118 <a href="#">→code</a> |
    | Consequências práticas de como os dicionários funcionam | Pág. 121 <a href="#">→code</a> |
    | Como os conjuntos funcionam – consequências práticas | Pág. 125 <a href="#">→code</a> |
    | Resumo do capítulo | Pág. 125 |
    | Leituras complementares | Pág. 126 |

</br>

  - **➥ Capítulo 4 - Texto versus bytes — Pág. 129**
    | Conteúdo | Pág./code |
    |:-:|:-:|
    | Falhas de caracteres | Pág. 130 <a href="#">→code</a> |
    | O essencial sobre bytes | Pág. 131 <a href="#">→code</a> |
    | Structs e memory views | Pág. 134 <a href="#">→code</a> |
    | Codificadores/decodificadores básicos | Pág. 135 <a href="#">→code</a> |
    | Entendendo os problemas de codificação/decodificação | Pág. 137 <a href="#">→code</a> |
    | Lidando com UnicodeEncodeError | Pág. 138 <a href="#">→code</a> |
    | Lidando com UnicodeDecodeError | Pág. 139 <a href="#">→code</a> |
    | SyntaxError ao carregar módulos com codificação inesperada | Pág. 140 <a href="#">→code</a> |
    | Como descobrir a codificação de uma sequência de bytes | Pág. 142 <a href="#">→code</a> |
    | BOM: um gremlin útil | Pág. 142 <a href="#">→code</a> |
    | Lidando com arquivos-texto | Pág. 144 <a href="#">→code</a> |
    | Defaults de codificação: um hospício | Pág. 147 <a href="#">→code</a> |
    | Normalizando Unicode para comparações mais seguras | Pág. 150 <a href="#">→code</a> |
    | Case folding | Pág. 153 <a href="#">→code</a> |
    | Funções utilitárias para comparações normalizadas | Pág. 154 <a href="#">→code</a> |
    | “Normalização” extrema: removendo acentos | Pág. 155 <a href="#">→code</a> |
    | Ordenação de texto Unicode | Pág. 159 <a href="#">→code</a> |
    | Ordenação com o Unicode Collation Algorithm | Pág. 161 <a href="#">→code</a> |
    | Base de dados Unicode | Pág. 161 <a href="#">→code</a> |
    | APIs de modo dual para str e bytes | Pág. 163 <a href="#">→code</a> |
    | str versus bytes em expressões regulares | Pág. 163 <a href="#">→code</a> |
    | str versus bytes em funções de os | Pág. 165 <a href="#">→code</a> |
    | Resumo do capítulo | Pág. 167 |
    | Leituras complementares | Pág. 169 |

</br>

### ***➲ Parte III - Funções como objetos — Pág. 174***
  - **➥ Capítulo 5 - Funções de primeira classe — Pág. 175**
    | Conteúdo | Pág./code |
    |:-:|:-:|
    | Tratando uma função como um objeto | Pág. 176 <a href="#">→code</a> |
    | Funções de ordem superior | Pág. 177 <a href="#">→code</a> |
    | Substitutos modernos para map, filter e reduce | Pág. 178 <a href="#">→code</a> |
    | Funções anônimas | Pág. 180 <a href="#">→code</a> |
    | As sete variações de objetos invocáveis | Pág. 181 <a href="#">→code</a> |
    | Tipos invocáveis definidos pelo usuário | Pág. 182 <a href="#">→code</a> |
    | Introspecção de função | Pág. 183 <a href="#">→code</a> |
    | De parâmetros posicionais a parâmetros exclusivamente nomeados | Pág. 185 <a href="#">→code</a> |
    | Obtendo informações sobre parâmetros | Pág. 187 <a href="#">→code</a> |
    | Anotações de função | Pág. 192 <a href="#">→code</a> |
    | Pacotes para programação funcional | Pág. 194 <a href="#">→code</a> |
    | Módulo operator | Pág. 194 <a href="#">→code</a> |
    | Congelando argumentos com functools.partia | Pág. 198 <a href="#">→code</a> |
    | Resumo do capítulo | Pág. 200 |
    | Leituras complementares | Pág. 201 |

</br>

  - **➥ Capítulo 6 - Padrões de projeto com funções de primeira classe — Pág. 205**
    | Conteúdo | Pág./code |
    |:-:|:-:|
    | Estudo de caso: refatorando Strategy | Pág. 206 <a href="#">→code</a> |
    | Strategy clássico | Pág. 206 <a href="#">→code</a> |
    | Strategy orientado a função | Pág. 210 <a href="#">→code</a> |
    | Escolhendo a melhor estratégia: abordagem simples | Pág. 213 <a href="#">→code</a> |
    | Encontrando estratégias em um módulo | Pág. 214 <a href="#">→code</a> |
    | Command | Pág. 216 <a href="#">→code</a> |
    | Resumo do capítulo | Pág. 218 |
    | Leituras complementares | Pág. 219 |

</br>

  - **➥ Capítulo 7 - Decoradores de diversão e fechamentos — Pág. 222**
    | Conteúdo | Pág./code |
    |:-:|:-:|
    | Básico sobre decoradores | Pág. 223 <a href="#">→code</a> |
    | Quando Python executa os decoradores | Pág. 224 <a href="#">→code</a> |
    | Padrão Strategy melhorado com decorador | Pág. 226 <a href="#">→code</a> |
    | Regras para escopo de variáveis | Pág. 228 <a href="#">→code</a> |
    | Closures | Pág. 232 <a href="#">→code</a> |
    | Declaração nonlocal | Pág. 235 <a href="#">→code</a> |
    | Implementando um decorador simples | Pág. 237 <a href="#">→code</a> |
    | Funcionamento | Pág. 238 <a href="#">→code</a> |
    | Decoradores da biblioteca-padrão | Pág. 240 <a href="#">→code</a> |
    | Memoização com functools.lru_cache | Pág. 240 <a href="#">→code</a> |
    | Funções genéricas com dispatch simples | Pág. 243 <a href="#">→code</a> |
    | Decoradores empilhados | Pág. 246 <a href="#">→code</a> |
    | Decoradores parametrizados | Pág. 247 <a href="#">→code</a> |
    | Um decorador de registro parametrizado | Pág. 247 <a href="#">→code</a> |
    | Decorador clock parametrizado | Pág. 249 <a href="#">→code</a> |
    | Resumo do capítulo | Pág. 252 |
    | Leituras complementares | Pág. 253 |

</br>

### ***➲ Parte IV - Práticas de orientação a objetos — Pág. 257***
  - **➥ Capítulo 8 - Referências a objetos, mutabilidades e recálagem — Pág. 258**
    | Conteúdo | Pág./code |
    |:-:|:-:|
    | Variáveis não são caixas | Pág. 259 <a href="#">→code</a> |
    | Identidade, igualdade e apelidos | Pág. 260 <a href="#">→code</a> |
    | Escolhendo entre == e is | Pág. 262 <a href="#">→code</a> |
    | A relativa imutabilidade das tuplas | Pág. 263 <a href="#">→code</a> |
    | Cópias são rasas por padrão | Pág. 264 <a href="#">→code</a> |
    | Cópias profundas e rasas de objetos quaisquer | Pág. 267 <a href="#">→code</a> |
    | Parâmetros de função como referências | Pág. 268 <a href="#">→code</a> |
    | Tipos mutáveis como default de parâmetros: péssima ideia | Pág. 270 <a href="#">→code</a> |
    | Programação defensiva com parâmetros mutáveis | Pág. 272 <a href="#">→code</a> |
    | del e coleta de lixo | Pág. 274 <a href="#">→code</a> |
    | Referências fracas | Pág. 276 <a href="#">→code</a> |
    | Esquete com WeakValueDictionary | Pág. 277 <a href="#">→code</a> |
    | Limitações das referências fracas | Pág. 279 <a href="#">→code</a> |
    | Truques de Python com imutáveis | Pág. 280 <a href="#">→code</a> |
    | Resumo do capítulo | Pág. 282 |
    | Leituras complementares | Pág. 283 |

</br>

  - **➥ Capítulo 9 - Um objeto pythônico — Pág. 288**
    | Conteúdo | Pág./code |
    |:-:|:-:|
    | Representações de objetos | Pág. 289 <a href="#">→code</a> |
    | Retorno da classe Vector | Pág. 289 <a href="#">→code</a> |
    | Um construtor alternativo | Pág. 292 <a href="#">→code</a> |
    | classmethod versus staticmethod | Pág. 293 <a href="#">→code</a> |
    | Apresentações formatadas | Pág. 295 <a href="#">→code</a> |
    | Um Vector2d hashable | Pág. 298 <a href="#">→code</a> |
    | Atributos privados e “protegidos” em Python | Pág. 304 <a href="#">→code</a> |
    | Economia de espaço com o atributo de classe _slots__ | Pág. 307 <a href="#">→code</a> |
    | Os problemas com _slots__ | Pág. 309 <a href="#">→code</a> |
    | Sobrescrita de atributos de classe | Pág. 310 <a href="#">→code</a> |
    | Resumo do capítulo | Pág. 312 |
    | Leituras complementares | Pág. 313 |

</br>

  - **➥ Capítulo 10 - Hackeando e fatiando sequências — Pág. 318**
    | Conteúdo | Pág./code |
    |:-:|:-:|
    | Vector: um tipo de sequência definido pelo usuário | Pág. 319 <a href="#">→code</a> |
    | Vector tomada #1: compatível com Vector2d | Pág. 319 <a href="#">→code</a> |
    | Protocolos e duck typing | Pág. 322 <a href="#">→code</a> |
    | Vector tomada #2: uma sequência que permite fatiamento | Pág. 323 <a href="#">→code</a> |
    | Como funciona o fatiamento | Pág. 324 <a href="#">→code</a> |
    | Hum __getitem_ que considera fatias | Pág. 327 <a href="#">→code</a> |
    | Vector tomada #3: acesso dinâmico a atributos | Pág. 328 <a href="#">→code</a> |
    | Vector tomada #4: hashing e um == mais rápido | Pág. 332 <a href="#">→code</a> |
    | Vector tomada #5: formatação | Pág. 338 <a href="#">→code</a> |
    | Resumo do capítulo | Pág. 345 |
    | Leituras complementares | Pág. 347 |

</br>

  - **➥ Capítulo 11 - Interfaces: de protocolos a ABCs — Pág. 352**
    | Conteúdo | Pág./code |
    |:-:|:-:|
    | Interfaces e protocolos na cultura de Python | Pág. 353 <a href="#">→code</a> |
    | Python curte sequências | Pág. 355 <a href="#">→code</a> |
    | Monkey-patching para implementar um protocolo em tempo de execução | Pág. 357 <a href="#">→code</a> |
    | Aves aquáticas de Alex Martelli | Pág. 359 <a href="#">→code</a> |
    | Criando subclasses de uma ABC | Pág. 365 <a href="#">→code</a> |
    | ABCs da biblioteca-padrão | Pág. 367 <a href="#">→code</a> |
    | ABCs em collections.abc | Pág. 367 <a href="#">→code</a> |
    | A torre numérica de ABCs | Pág. 369 <a href="#">→code</a> |
    | Definindo e usando uma ABC | Pág. 370 <a href="#">→code</a> |
    | Detalhes de sintaxe das ABCs | Pág. 374 <a href="#">→code</a> |
    | Herdando da ABC Tombola | Pág. 375 <a href="#">→code</a> |
    | Uma subclasse virtual de Tombola | Pág. 378 <a href="#">→code</a> |
    | Como as subclasses de Tombola foram testadas | Pág. 381 <a href="#">→code</a> |
    | Uso de register na prática | Pág. 384 <a href="#">→code</a> |
    | Gansos podem se comportar como patos | Pág. 385 <a href="#">→code</a> |
    | Resumo do capítulo | Pág. 386 |
    | Leituras complementares | Pág. 389 |

</br>

  - **➥ Capítulo 12 - Herança: para o bem ou para o mal — Pág. 395**
    | Conteúdo | Pág./code |
    |:-:|:-:|
    | Artimanhas da criação de subclasses de tipos embutidos | Pág. 396 <a href="#">→code</a> |
    | Herança múltipla e ordem de resolução de métodos | Pág. 399 <a href="#">→code</a> |
    | Herança múltipla no mundo real | Pág. 404 <a href="#">→code</a> |
    | ↓ Lidando com herança múltipla | Pág. 407 <a href="#">→code</a> |
    | → 1. Faça uma distinção entre a herança de interface e a herança de implementação | Pág. 407 |
    | → 2. Deixe como interfaces explícitas com ABCs | Pág. 407 |
    | → 3. Use mixins para reutilização de código | Pág. 407 |
    | → 4. Explique como mixins pelo nome | Pág. 408 |
    | → 5. Uma ABC pode ser uma mistura; o contrário não é verdade | Pág. 408 |
    | → 6. Não há mais de uma classe concreta | Pág. 408 |
    | → 7. Aulas de Ofereça agregadas aos usuários | Pág. 409 |
    | → 8. “Prefira composição de objetos à herança de classe." | Pág. 409 |
    | Tkinter: o bom, o ruim e o feio | Pág. 410 <a href="#">→code</a> |
    | Um exemplo moderno: mixins em views genéricas de Django | Pág. 411 <a href="#">→code</a> |
    | Resumo do capítulo | Pág. 414  |
    | Leituras complementares | Pág. 415 |
    
</br>

  - **➥ Capítulo 13 - Sobrecarga de operadores: o jeito certo — Pág. 419**
    | Conteúdo | Pág./code |
    |:-:|:-:|
    | Básico da sobrecarga de operadores | Pág. 420 <a href="#">→code</a> |
    | Operadores unários | Pág. 420 <a href="#">→code</a> |
    | Sobrecarregando + para soma de vetores | Pág. 423 <a href="#">→code</a> |
    | Sobrecarregando * para multiplicação por escalar | Pág. 429 <a href="#">→code</a> |
    | Operadores de comparação rica | Pág. 433 <a href="#">→code</a> |
    | Operadores de atribuição combinada | Pág. 438 <a href="#">→code</a> |
    | Resumo do capítulo | Pág. 443 |
    | Leituras complementares | Pág. 444 |

</br>

### ***➲ Parte V - Controle de fluxo — Pág. 449***
  - **➥ Capítulo 14 - Iterários, iteradores e geradores — Pág. 450**
    | Conteúdo | Pág./code |
    |:-:|:-:|
    | Sentence tomada #1: uma sequência de palavras | Pág. 451 <a href="#">→code</a> |
    | Por que sequências são iteráveis: a função iter | Pág. 453 <a href="#">→code</a> |
    | Iteráveis versus iteradores | Pág. 455 <a href="#">→code</a> |
    | Sentence tomada #2: um iterador clássico | Pág. 459 <a href="#">→code</a> |
    | Fazer de Sentence um iterador: péssima ideia | Pág. 460 <a href="#">→code</a> |
    | Sentence tomada #3: uma função geradora | Pág. 461 <a href="#">→code</a> |
    | Como funciona uma função geradora | Pág. 462 <a href="#">→code</a> |
    | Sentence tomada #4: uma implementação lazy | Pág. 466 <a href="#">→code</a> |
    | Sentence tomada #5: uma expressão geradora | Pág. 467 <a href="#">→code</a> |
    | Expressões geradoras: quando usá-las | Pág. 469 <a href="#">→code</a> |
    | Outro exemplo: gerador de progressão aritmética | Pág. 470 <a href="#">→code</a> |
    | Progressão aritmética com itertools | Pág. 473 <a href="#">→code</a> |
    | Funções geradoras na biblioteca-padrão | Pág. 474 <a href="#">→code</a> |
    | Nova sintaxe em Python 3.3: yield from | Pág. 485 <a href="#">→code</a> |
    | Funções de redução de iteráveis | Pág. 486 <a href="#">→code</a> |
    | Uma visão mais detalhada da função iter | Pág. 488 <a href="#">→code</a> |
    | Estudo de caso: geradores em um utilitário para conversão de banco de dados | Pág. 489 <a href="#">→code</a> |
    | Geradores como corrotinas | Pág. 491 <a href="#">→code</a> |
    | Resumo do capítulo | Pág. 492 |
    | Leituras complementares | Pág. 493 |

</br>

  - **➥ Capítulo 15 - Gerenciadores de contexto e blocos — Pág. 499**
    | Conteúdo | Pág./code |
    |:-:|:-:|
    | Faça isso, então aquilo: blocos else além de if | Pág. 500 <a href="#">→code</a> |
    | Gerenciadores de contexto e blocos with | Pág. 502 <a href="#">→code</a> |
    | Utilitários de contextlib | Pág. 507 <a href="#">→code</a> |
    | Usando @gerente de contexto | Pág. 508 <a href="#">→code</a> |
    | Resumo do capítulo | Pág. 512 |
    | Leituras complementares | Pág. 512 |

</br>

  - **➥ Capítulo 16 - Corrotinas — Pág. 515**
    | Conteúdo | Pág./code |
    |:-:|:-:|
    | Como as corrotinas evoluíram a partir de geradores | Pág. 516 <a href="#">→code</a> |
    | Comportamento básico de um gerador usado como corrotina | Pág. 517 <a href="#">→code</a> |
    | Exemplo: corrotina para calcular uma média cumulativa | Pág. 520 <a href="#">→code</a> |
    | Decoradores para preparação de corrotinas | Pág. 522 <a href="#">→code</a> |
    | Término de corrotinas e tratamento de exceção | Pág. 524 <a href="#">→code</a> |
    | Devolvendo um valor a partir de uma corrotina | Pág. 528 <a href="#">→code</a> |
    | Usando yield from | Pág. 530 <a href="#">→code</a> |
    | O significado de yield from | Pág. 536 <a href="#">→code</a> |
    | Caso de uso: corrotinas para uma simulação de eventos discretos | Pág. 543 <a href="#">→code</a> |
    | Sobre simulações de eventos discretos | Pág. 543 <a href="#">→code</a> |
    | A simulação da frota de táxis | Pág. 544 <a href="#">→code</a> |
    | Resumo do capítulo | Pág. 552 |
    | Leituras complementares | Pág. 554 |
  
</br>

  - **➥ Capítulo 17 - Concorrência com futuros — Pág. 560**
    | Conteúdo | Pág./code |
    |:-:|:-:|
    | Exemplo: downloads da Web em três estilos | Pág. 560 <a href="#">→code</a> |
    | Um script para download sequencial | Pág. 563 <a href="#">→code</a> |
    | Fazendo download com concurrent.futures | Pág. 565 <a href="#">→code</a> |
    | Onde estão os futures? | Pág. 566 <a href="#">→code</a> |
    | E/S bloqueante e a GIL | Pág. 570 <a href="#">→code</a> |
    | Iniciando processos com concurrent.futures | Pág. 571 <a href="#">→code</a> |
    | Fazendo experimentos com Executor.map | Pág. 573 <a href="#">→code</a> |
    | Downloads com exibição de progresso e tratamento de erros | Pág. 576 <a href="#">→code</a> |
    | Tratamento de erros nos exemplos da série flags2 | Pág. 581 <a href="#">→code</a> |
    | Usando futures.as_completed | Pág. 584 <a href="#">→code</a> |
    | Alternativas com threading e multiprocessing | Pág. 587 <a href="#">→code</a> |
    | Resumo do capítulo | Pág. 587 |
    | Leituras complementares | Pág. 588 |

</br>

  - **➥ Capítulo 18 - Concorrência com assyncio — Pág. 594**
    | Conteúdo | Pág./code |
    |:-:|:-:|
    | Thread versus corrotina: uma comparação | Pág. 596 <a href="#">→code</a> |
    | asyncio.Future: não bloqueante por design | Pág. 603 <a href="#">→code</a> |
    | yield from com futures, tasks e corrotinas | Pág. 604 <a href="#">→code</a> |
    | Fazendo download com asyncio e aiohttp | Pág. 605 <a href="#">→code</a> |
    | Dando voltas em chamadas bloqueantes | Pág. 610 <a href="#">→code</a> |
    | Melhorando o script para download com asyncio | Pág. 612 <a href="#">→code</a> |
    | Usando asyncio.as_completed | Pág. 613 <a href="#">→code</a> |
    | Usando um executor para evitar bloqueio do loop de eventos | Pág. 619 <a href="#">→code</a> |
    | De callbacks a futures e corrotinas | Pág. 620 <a href="#">→code</a> |
    | Fazendo várias requisições para cada download | Pág. 623 <a href="#">→code</a> |
    | Escrevendo servidores com asyncio | Pág. 626 <a href="#">→code</a> |
    | Um servidor TCP com asyncio | Pág. 627 <a href="#">→code</a> |
    | Um servidor web com aiohttp | Pág. 632 <a href="#">→code</a> |
    | Clientes mais inteligentes para melhorar a concorrência | Pág. 636 <a href="#">→code</a> |
    | Resumo do capítulo | Pág. 637 |
    | Leituras complementares | Pág. 638 |

</br>

### ***➲ Parte VI - Metaprogramação — Pág. 643***
  - **➥ Capítulo 19 - Atributos dinâmicos e propriações — Pág. 644**
    | Conteúdo | Pág./code |
    |:-:|:-:|
    | Processando dados com atributos dinâmicos | Pág. 645 <a href="#">→code</a> |
    | Explorando dados JSON ou similares com atributos dinâmicos | Pág. 647 <a href="#">→code</a> |
    | O problema do nome de atributo inválido | Pág. 651 <a href="#">→code</a> |
    | Criação flexível de objetos com _novo__ | Pág. 652 <a href="#">→code</a> |
    | Reestruturando o feed da OSCON com shelve | Pág. 654 <a href="#">→code</a> |
    | Recuperação de registros relacionados usando propriedades | Pág. 658 <a href="#">→code</a> |
    | Usando uma propriedade para validação de atributo | Pág. 665 <a href="#">→code</a> |
    | LineItem tomada #1: classe para um item de um pedido | Pág. 665 <a href="#">→code</a> |
    | LineItem tomada #2: uma propriedade com validação | Pág. 666 <a href="#">→code</a> |
    | Uma visão apropriada das propriedades | Pág. 667 <a href="#">→code</a> |
    | Propriedades encobrem atributos de instância | Pág. 669 <a href="#">→code</a> |
    | Documentação de propriedades | Pág. 672 <a href="#">→code</a> |
    | Implementando uma fábrica de propriedades | Pág. 673 <a href="#">→code</a> |
    | Tratando a remoção de atributos | Pág. 676 <a href="#">→code</a> |
    | Atributos e funções essenciais para tratamento de atributos | Pág. 677 <a href="#">→code</a> |
    | Atributos especiais que afetam o tratamento de atributos | Pág. 677 <a href="#">→code</a> |
    | Funções embutidas para tratamento de atributos | Pág. 678 <a href="#">→code</a> |
    | Métodos especiais para tratamento de atributos | Pág. 679 <a href="#">→code</a> |
    | Resumo do capítulo | Pág. 681 |
    | Leituras complementares | Pág. 681 |

</br>

  - **➥ Capítulo 20 - Descritores de atributos — Pág. 687**
    | Conteúdo | Pág./code |
    |:-:|:-:|
    | Exemplo de descritor: validação de atributos | Pág. 687 <a href="#">→code</a> |
    | LineItem tomada #3: um descritor simples | Pág. 688 <a href="#">→code</a> |
    | LineItem tomada #4: nomes automáticos para atributos de armazenagem | Pág. 693 <a href="#">→code</a> |
    | LineItem tomada #5: um novo tipo descritor | Pág. 700 <a href="#">→code</a> |
    | Descritores dominantes e não dominantes | Pág. 703 <a href="#">→code</a> |
    | Descritor dominante | Pág. 705 <a href="#">→code</a> |
    | Descritor dominante sem _get__ | Pág. 706 <a href="#">→code</a> |
    | Descritor não dominante | Pág. 707 <a href="#">→code</a> |
    | Sobrescrevendo um descritor na classe | Pág. 709 <a href="#">→code</a> |
    | Métodos são descritores | Pág. 709 <a href="#">→code</a> |
    | Dicas para uso de descritores | Pág. 712 <a href="#">→code</a> |
    | Docstring de descritores e controle de remoção | Pág. 714 <a href="#">→code</a> |
    | Resumo do capítulo | Pág. 715 |
    | Leituras complementares | Pág. 716 |

</br>

  - **➥ Capítulo 21 - Metaprogramação com aulas — Pág. 718**
    | Conteúdo | Pág./code |
    |:-:|:-:|
    | Uma fábrica de classes | Pág. 719 <a href="#">→code</a> |
    | Um decorador de classe para personalizar descritores | Pág. 722 <a href="#">→code</a> |
    | O que acontece quando: tempo de importação versus tempo de execução | Pág. 725 <a href="#">→code</a> |
    | Exercícios dos instantes de avaliação | Pág. 726 <a href="#">→code</a> |
    | Básico sobre metaclasses | Pág. 730 <a href="#">→code</a> |
    | Exercício do instante de avaliação de metaclasses | Pág. 732 <a href="#">→code</a> |
    | Uma metaclasse para personalizar descritores | Pág. 736 <a href="#">→code</a> |
    | Método especial _prepare__ de metaclasse | Pág. 738 <a href="#">→code</a> |
    | Classes como objetos | Pág. 741 <a href="#">→code</a> |
    | Resumo do capítulo | Pág. 742 <a href="#">→code</a> |
    | Leituras complementares | Pág. 743 <a href="#">→code</a> |
    | Posfácio | Pág. 747 |
    | Leituras complementares | Pág. 749 |

</br>

### ***➲ Apêndice A - Scripts auxiliares — Pág. 751***
  | Conteúdo | Pág./code |
  |:-:|:-:|
  | Capítulo 3: teste de desempenho do operador in | Pág. 751 <a href="#">→code</a> |
  | Capítulo 3: comparar padrões de bits de hashes | Pág. 754 <a href="#">→code</a> |
  | Capítulo 9: uso da RAM com e sem _slots__ 754 | Pág. <a href="#">→code</a> |
  | Capítulo 14: script isis2json.py para conversão de banco de dados | Pág. 755 <a href="#">→code</a> |
  | Capítulo 16: simulação de eventos discretos para a frota de táxis | Pág. 761 <a href="#">→code</a> |
  | Capítulo 17: Exemplos com criptografia | Pág. 766 <a href="#">→code</a> |
  | Capítulo 17: exemplos de cliente HTTP para flags2 | Pág. 769 <a href="#">→code</a> |
  | Capítulo 19: Scripts e testes para agenda da OSCON | Pág. 775 <a href="#">→code</a> |
  | Jargão de Python | Pág. 781 |
  | Sobre o autor | Pág. 798 |
  | Colofão | Pág. 799 |
